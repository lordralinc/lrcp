/* tslint:disable */
/* eslint-disable */
/**
 * LRCP API
 * Панель управления сервером
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface APIError
 */
export interface APIError {
    /**
     * 
     * @type {APIExceptionType}
     * @memberof APIError
     */
    'type': APIExceptionType;
    /**
     * 
     * @type {string}
     * @memberof APIError
     */
    'message': string;
    /**
     * 
     * @type {object | Array<object>}
     * @memberof APIError
     */
    'extra': object | Array<object>;
}
/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const APIExceptionType = {
    ValidationError: 'ValidationError',
    InactiveUser: 'InactiveUser',
    InvalidCredit: 'InvalidCredit',
    NeedTwoFactorCode: 'NeedTwoFactorCode',
    NotFound: 'NotFound',
    CantConnectToServer: 'CantConnectToServer',
    Unknown: 'Unknown'
} as const;

export type APIExceptionType = typeof APIExceptionType[keyof typeof APIExceptionType];


/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const CloseCodeEnum = {
    NUMBER_1000: 1000,
    NUMBER_4000: 4000,
    NUMBER_4001: 4001,
    NUMBER_4002: 4002
} as const;

export type CloseCodeEnum = typeof CloseCodeEnum[keyof typeof CloseCodeEnum];


/**
 * 
 * @export
 * @interface CloseSocketsData
 */
export interface CloseSocketsData {
    /**
     * 
     * @type {string}
     * @memberof CloseSocketsData
     */
    'command'?: CloseSocketsDataCommandEnum;
    /**
     * 
     * @type {CloseCodeEnum}
     * @memberof CloseSocketsData
     */
    'close_code'?: CloseCodeEnum;
}

export const CloseSocketsDataCommandEnum = {
    CloseSockets: 'closeSockets'
} as const;

export type CloseSocketsDataCommandEnum = typeof CloseSocketsDataCommandEnum[keyof typeof CloseSocketsDataCommandEnum];

/**
 * 
 * @export
 * @interface DeleteServerResponse
 */
export interface DeleteServerResponse {
    /**
     * 
     * @type {boolean}
     * @memberof DeleteServerResponse
     */
    'success': boolean;
}
/**
 * 
 * @export
 * @interface Get2FAData
 */
export interface Get2FAData {
    /**
     * 
     * @type {string}
     * @memberof Get2FAData
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof Get2FAData
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface GetMasterInfoResponse
 */
export interface GetMasterInfoResponse {
    /**
     * 
     * @type {string}
     * @memberof GetMasterInfoResponse
     */
    'ip': string;
    /**
     * 
     * @type {number}
     * @memberof GetMasterInfoResponse
     */
    'port': number;
}
/**
 * 
 * @export
 * @interface GetSelfUserResponse
 */
export interface GetSelfUserResponse {
    /**
     * 
     * @type {string}
     * @memberof GetSelfUserResponse
     */
    'username': string;
    /**
     * 
     * @type {boolean}
     * @memberof GetSelfUserResponse
     */
    'two_factor_enabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof GetSelfUserResponse
     */
    'full_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetSelfUserResponse
     */
    'email'?: string;
}
/**
 * 
 * @export
 * @interface GetServerInfoResponse
 */
export interface GetServerInfoResponse {
    /**
     * 
     * @type {string}
     * @memberof GetServerInfoResponse
     */
    'os_name': string;
    /**
     * 
     * @type {string}
     * @memberof GetServerInfoResponse
     */
    'os_release': string;
    /**
     * 
     * @type {string}
     * @memberof GetServerInfoResponse
     */
    'uptime': string;
}
/**
 * 
 * @export
 * @interface GetServerMonitorWSResponse
 */
export interface GetServerMonitorWSResponse {
    /**
     * 
     * @type {string}
     * @memberof GetServerMonitorWSResponse
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof GetServerMonitorWSResponse
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface GetServerResponse
 */
export interface GetServerResponse {
    /**
     * 
     * @type {number}
     * @memberof GetServerResponse
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof GetServerResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GetServerResponse
     */
    'connect_time': string;
    /**
     * 
     * @type {string}
     * @memberof GetServerResponse
     */
    'api_key': string;
    /**
     * 
     * @type {boolean}
     * @memberof GetServerResponse
     */
    'online': boolean;
    /**
     * 
     * @type {string}
     * @memberof GetServerResponse
     */
    'ip_address': string;
    /**
     * 
     * @type {number}
     * @memberof GetServerResponse
     */
    'grpc_port': number;
}
/**
 * 
 * @export
 * @interface MemoryInfo
 */
export interface MemoryInfo {
    /**
     * 
     * @type {number}
     * @memberof MemoryInfo
     */
    'mem_total'?: number;
    /**
     * 
     * @type {number}
     * @memberof MemoryInfo
     */
    'mem_free'?: number;
    /**
     * 
     * @type {number}
     * @memberof MemoryInfo
     */
    'mem_available'?: number;
    /**
     * 
     * @type {number}
     * @memberof MemoryInfo
     */
    'buffers'?: number;
    /**
     * 
     * @type {number}
     * @memberof MemoryInfo
     */
    'cached'?: number;
    /**
     * 
     * @type {number}
     * @memberof MemoryInfo
     */
    'swap_cached'?: number;
    /**
     * 
     * @type {number}
     * @memberof MemoryInfo
     */
    'active'?: number;
    /**
     * 
     * @type {number}
     * @memberof MemoryInfo
     */
    'inactive'?: number;
    /**
     * 
     * @type {number}
     * @memberof MemoryInfo
     */
    'active_anon'?: number;
    /**
     * 
     * @type {number}
     * @memberof MemoryInfo
     */
    'inactive_anon'?: number;
    /**
     * 
     * @type {number}
     * @memberof MemoryInfo
     */
    'active_file'?: number;
    /**
     * 
     * @type {number}
     * @memberof MemoryInfo
     */
    'inactive_file'?: number;
    /**
     * 
     * @type {number}
     * @memberof MemoryInfo
     */
    'unevictable'?: number;
    /**
     * 
     * @type {number}
     * @memberof MemoryInfo
     */
    'mlocked'?: number;
    /**
     * 
     * @type {number}
     * @memberof MemoryInfo
     */
    'swap_total'?: number;
    /**
     * 
     * @type {number}
     * @memberof MemoryInfo
     */
    'swap_free'?: number;
    /**
     * 
     * @type {number}
     * @memberof MemoryInfo
     */
    'dirty'?: number;
    /**
     * 
     * @type {number}
     * @memberof MemoryInfo
     */
    'writeback'?: number;
    /**
     * 
     * @type {number}
     * @memberof MemoryInfo
     */
    'anon_pages'?: number;
    /**
     * 
     * @type {number}
     * @memberof MemoryInfo
     */
    'mapped'?: number;
    /**
     * 
     * @type {number}
     * @memberof MemoryInfo
     */
    'shmem'?: number;
    /**
     * 
     * @type {number}
     * @memberof MemoryInfo
     */
    'kreclaimable'?: number;
    /**
     * 
     * @type {number}
     * @memberof MemoryInfo
     */
    'slab'?: number;
    /**
     * 
     * @type {number}
     * @memberof MemoryInfo
     */
    'sreclaimable'?: number;
    /**
     * 
     * @type {number}
     * @memberof MemoryInfo
     */
    'sunreclaim'?: number;
    /**
     * 
     * @type {number}
     * @memberof MemoryInfo
     */
    'kernel_stack'?: number;
    /**
     * 
     * @type {number}
     * @memberof MemoryInfo
     */
    'page_tables'?: number;
    /**
     * 
     * @type {number}
     * @memberof MemoryInfo
     */
    'nfs_unstable'?: number;
    /**
     * 
     * @type {number}
     * @memberof MemoryInfo
     */
    'bounce'?: number;
    /**
     * 
     * @type {number}
     * @memberof MemoryInfo
     */
    'writeback_tmp'?: number;
    /**
     * 
     * @type {number}
     * @memberof MemoryInfo
     */
    'commit_limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof MemoryInfo
     */
    'committed_as'?: number;
    /**
     * 
     * @type {number}
     * @memberof MemoryInfo
     */
    'vmalloc_total'?: number;
    /**
     * 
     * @type {number}
     * @memberof MemoryInfo
     */
    'vmalloc_used'?: number;
    /**
     * 
     * @type {number}
     * @memberof MemoryInfo
     */
    'vmalloc_chunk'?: number;
    /**
     * 
     * @type {number}
     * @memberof MemoryInfo
     */
    'percpu'?: number;
    /**
     * 
     * @type {number}
     * @memberof MemoryInfo
     */
    'hardware_corrupted'?: number;
    /**
     * 
     * @type {number}
     * @memberof MemoryInfo
     */
    'anon_huge_pages'?: number;
    /**
     * 
     * @type {number}
     * @memberof MemoryInfo
     */
    'shmem_huge_pages'?: number;
    /**
     * 
     * @type {number}
     * @memberof MemoryInfo
     */
    'shmem_pmd_mapped'?: number;
    /**
     * 
     * @type {number}
     * @memberof MemoryInfo
     */
    'file_huge_pages'?: number;
    /**
     * 
     * @type {number}
     * @memberof MemoryInfo
     */
    'file_pmd_mapped'?: number;
    /**
     * 
     * @type {number}
     * @memberof MemoryInfo
     */
    'huge_pages_total'?: number;
    /**
     * 
     * @type {number}
     * @memberof MemoryInfo
     */
    'huge_pages_free'?: number;
    /**
     * 
     * @type {number}
     * @memberof MemoryInfo
     */
    'huge_pages_rsvd'?: number;
    /**
     * 
     * @type {number}
     * @memberof MemoryInfo
     */
    'huge_pages_surp'?: number;
    /**
     * 
     * @type {number}
     * @memberof MemoryInfo
     */
    'hugepagesize'?: number;
    /**
     * 
     * @type {number}
     * @memberof MemoryInfo
     */
    'hugetlb'?: number;
    /**
     * 
     * @type {number}
     * @memberof MemoryInfo
     */
    'direct_map_4k'?: number;
    /**
     * 
     * @type {number}
     * @memberof MemoryInfo
     */
    'direct_map_2m'?: number;
    /**
     * 
     * @type {number}
     * @memberof MemoryInfo
     */
    'direct_map_1g'?: number;
}
/**
 * 
 * @export
 * @interface SendMessageData
 */
export interface SendMessageData {
    /**
     * 
     * @type {string}
     * @memberof SendMessageData
     */
    'command'?: SendMessageDataCommandEnum;
    /**
     * 
     * @type {string}
     * @memberof SendMessageData
     */
    'message': string;
}

export const SendMessageDataCommandEnum = {
    SendMessage: 'sendMessage'
} as const;

export type SendMessageDataCommandEnum = typeof SendMessageDataCommandEnum[keyof typeof SendMessageDataCommandEnum];

/**
 * 
 * @export
 * @interface Set2FAData
 */
export interface Set2FAData {
    /**
     * 
     * @type {number}
     * @memberof Set2FAData
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof Set2FAData
     */
    'totp_code': string;
}
/**
 * 
 * @export
 * @interface SetMemoryInfoData
 */
export interface SetMemoryInfoData {
    /**
     * 
     * @type {string}
     * @memberof SetMemoryInfoData
     */
    'command'?: SetMemoryInfoDataCommandEnum;
    /**
     * 
     * @type {MemoryInfo}
     * @memberof SetMemoryInfoData
     */
    'memory_info': MemoryInfo;
}

export const SetMemoryInfoDataCommandEnum = {
    SetMemoryInfo: 'setMemoryInfo'
} as const;

export type SetMemoryInfoDataCommandEnum = typeof SetMemoryInfoDataCommandEnum[keyof typeof SetMemoryInfoDataCommandEnum];

/**
 * 
 * @export
 * @interface Token
 */
export interface Token {
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    'access_token': string;
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    'token_type': string;
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Получение токена по логину и паролю
         * @summary Получение токена
         * @param {string} username 
         * @param {string} password 
         * @param {number} [twoFactorCode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccessToken: async (username: string, password: string, twoFactorCode?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('getAccessToken', 'username', username)
            // verify required parameter 'password' is not null or undefined
            assertParamExists('getAccessToken', 'password', password)
            const localVarPath = `/authToken`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();


            if (username !== undefined) { 
                localVarFormParams.set('username', username as any);
            }
    
            if (password !== undefined) { 
                localVarFormParams.set('password', password as any);
            }
    
            if (twoFactorCode !== undefined) { 
                localVarFormParams.set('two_factor_code', twoFactorCode as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * Получение токена по логину и паролю
         * @summary Получение токена
         * @param {string} username 
         * @param {string} password 
         * @param {number} [twoFactorCode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccessToken(username: string, password: string, twoFactorCode?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Token>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccessToken(username, password, twoFactorCode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * Получение токена по логину и паролю
         * @summary Получение токена
         * @param {string} username 
         * @param {string} password 
         * @param {number} [twoFactorCode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccessToken(username: string, password: string, twoFactorCode?: number, options?: any): AxiosPromise<Token> {
            return localVarFp.getAccessToken(username, password, twoFactorCode, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * Получение токена по логину и паролю
     * @summary Получение токена
     * @param {string} username 
     * @param {string} password 
     * @param {number} [twoFactorCode] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public getAccessToken(username: string, password: string, twoFactorCode?: number, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).getAccessToken(username, password, twoFactorCode, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MasterApi - axios parameter creator
 * @export
 */
export const MasterApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Получение информации о мастер сервере
         * @summary Получение мастера
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInfo: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/master`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MasterApi - functional programming interface
 * @export
 */
export const MasterApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MasterApiAxiosParamCreator(configuration)
    return {
        /**
         * Получение информации о мастер сервере
         * @summary Получение мастера
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInfo(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMasterInfoResponse<GetServerResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MasterApi - factory interface
 * @export
 */
export const MasterApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MasterApiFp(configuration)
    return {
        /**
         * Получение информации о мастер сервере
         * @summary Получение мастера
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInfo(options?: any): AxiosPromise<GetMasterInfoResponse<GetServerResponse>> {
            return localVarFp.getInfo(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MasterApi - object-oriented interface
 * @export
 * @class MasterApi
 * @extends {BaseAPI}
 */
export class MasterApi extends BaseAPI {
    /**
     * Получение информации о мастер сервере
     * @summary Получение мастера
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MasterApi
     */
    public getInfo(options?: AxiosRequestConfig) {
        return MasterApiFp(this.configuration).getInfo(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ServersApi - axios parameter creator
 * @export
 */
export const ServersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Получение сервера
         * @summary Получение сервера
         * @param {number} serverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteServer: async (serverId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            assertParamExists('deleteServer', 'serverId', serverId)
            const localVarPath = `/server/{server_id}`
                .replace(`{${"server_id"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получение сервера
         * @summary Получение сервера
         * @param {number} serverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServer: async (serverId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            assertParamExists('getServer', 'serverId', serverId)
            const localVarPath = `/server/{server_id}`
                .replace(`{${"server_id"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получение информации о сервере
         * @summary Получение информации о сервере
         * @param {number} serverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerInfo: async (serverId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            assertParamExists('getServerInfo', 'serverId', serverId)
            const localVarPath = `/serverInfo/{server_id}`
                .replace(`{${"server_id"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Server Monitor Ws
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerMonitorWS: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/server/monitorWS`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получение списка серверов
         * @summary Получение списка серверов
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServers: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/servers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServersApi - functional programming interface
 * @export
 */
export const ServersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServersApiAxiosParamCreator(configuration)
    return {
        /**
         * Получение сервера
         * @summary Получение сервера
         * @param {number} serverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteServer(serverId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteServerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteServer(serverId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Получение сервера
         * @summary Получение сервера
         * @param {number} serverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServer(serverId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetServerResponse<GetServerResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServer(serverId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Получение информации о сервере
         * @summary Получение информации о сервере
         * @param {number} serverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServerInfo(serverId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetServerInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServerInfo(serverId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Server Monitor Ws
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServerMonitorWS(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetServerMonitorWSResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServerMonitorWS(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Получение списка серверов
         * @summary Получение списка серверов
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServers(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetServerResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServers(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ServersApi - factory interface
 * @export
 */
export const ServersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServersApiFp(configuration)
    return {
        /**
         * Получение сервера
         * @summary Получение сервера
         * @param {number} serverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteServer(serverId: number, options?: any): AxiosPromise<DeleteServerResponse> {
            return localVarFp.deleteServer(serverId, options).then((request) => request(axios, basePath));
        },
        /**
         * Получение сервера
         * @summary Получение сервера
         * @param {number} serverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServer(serverId: number, options?: any): AxiosPromise<GetServerResponse<GetServerResponse>> {
            return localVarFp.getServer(serverId, options).then((request) => request(axios, basePath));
        },
        /**
         * Получение информации о сервере
         * @summary Получение информации о сервере
         * @param {number} serverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerInfo(serverId: number, options?: any): AxiosPromise<GetServerInfoResponse> {
            return localVarFp.getServerInfo(serverId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Server Monitor Ws
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerMonitorWS(options?: any): AxiosPromise<GetServerMonitorWSResponse> {
            return localVarFp.getServerMonitorWS(options).then((request) => request(axios, basePath));
        },
        /**
         * Получение списка серверов
         * @summary Получение списка серверов
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServers(options?: any): AxiosPromise<Array<GetServerResponse>> {
            return localVarFp.getServers(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ServersApi - object-oriented interface
 * @export
 * @class ServersApi
 * @extends {BaseAPI}
 */
export class ServersApi extends BaseAPI {
    /**
     * Получение сервера
     * @summary Получение сервера
     * @param {number} serverId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServersApi
     */
    public deleteServer(serverId: number, options?: AxiosRequestConfig) {
        return ServersApiFp(this.configuration).deleteServer(serverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получение сервера
     * @summary Получение сервера
     * @param {number} serverId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServersApi
     */
    public getServer(serverId: number, options?: AxiosRequestConfig) {
        return ServersApiFp(this.configuration).getServer(serverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получение информации о сервере
     * @summary Получение информации о сервере
     * @param {number} serverId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServersApi
     */
    public getServerInfo(serverId: number, options?: AxiosRequestConfig) {
        return ServersApiFp(this.configuration).getServerInfo(serverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Server Monitor Ws
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServersApi
     */
    public getServerMonitorWS(options?: AxiosRequestConfig) {
        return ServersApiFp(this.configuration).getServerMonitorWS(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получение списка серверов
     * @summary Получение списка серверов
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServersApi
     */
    public getServers(options?: AxiosRequestConfig) {
        return ServersApiFp(this.configuration).getServers(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Удалить 2FA
         * @summary Удалить 2FA
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete2FA: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/selfUser/2fa`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получить данные для 2FA
         * @summary Получить данные для 2FA
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get2FAData: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/selfUser/get2FA`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получение текущего пользователя
         * @summary Текущий пользователь
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSelf: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/selfUser`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Установить 2FA
         * @summary Установить 2FA
         * @param {Set2FAData} set2FAData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        set2FA: async (set2FAData: Set2FAData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'set2FAData' is not null or undefined
            assertParamExists('set2FA', 'set2FAData', set2FAData)
            const localVarPath = `/selfUser/2fa`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(set2FAData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * Удалить 2FA
         * @summary Удалить 2FA
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delete2FA(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSelfUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.delete2FA(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Получить данные для 2FA
         * @summary Получить данные для 2FA
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get2FAData(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2FAData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.get2FAData(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Получение текущего пользователя
         * @summary Текущий пользователь
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSelf(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSelfUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSelf(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Установить 2FA
         * @summary Установить 2FA
         * @param {Set2FAData} set2FAData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async set2FA(set2FAData: Set2FAData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSelfUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.set2FA(set2FAData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * Удалить 2FA
         * @summary Удалить 2FA
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete2FA(options?: any): AxiosPromise<GetSelfUserResponse> {
            return localVarFp.delete2FA(options).then((request) => request(axios, basePath));
        },
        /**
         * Получить данные для 2FA
         * @summary Получить данные для 2FA
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get2FAData(options?: any): AxiosPromise<Get2FAData> {
            return localVarFp.get2FAData(options).then((request) => request(axios, basePath));
        },
        /**
         * Получение текущего пользователя
         * @summary Текущий пользователь
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSelf(options?: any): AxiosPromise<GetSelfUserResponse> {
            return localVarFp.getSelf(options).then((request) => request(axios, basePath));
        },
        /**
         * Установить 2FA
         * @summary Установить 2FA
         * @param {Set2FAData} set2FAData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        set2FA(set2FAData: Set2FAData, options?: any): AxiosPromise<GetSelfUserResponse> {
            return localVarFp.set2FA(set2FAData, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * Удалить 2FA
     * @summary Удалить 2FA
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public delete2FA(options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).delete2FA(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получить данные для 2FA
     * @summary Получить данные для 2FA
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public get2FAData(options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).get2FAData(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получение текущего пользователя
     * @summary Текущий пользователь
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getSelf(options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getSelf(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Установить 2FA
     * @summary Установить 2FA
     * @param {Set2FAData} set2FAData 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public set2FA(set2FAData: Set2FAData, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).set2FA(set2FAData, options).then((request) => request(this.axios, this.basePath));
    }
}


