/* tslint:disable */
/* eslint-disable */
/**
 * LRCP API
 * Панель управления сервером
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration'
import globalAxios, { AxiosInstance, AxiosPromise, AxiosRequestConfig } from 'axios'
// Some imports not used depending on template conditions
// @ts-ignore
import {
  assertParamExists,
  createRequestFunction,
  DUMMY_BASE_URL,
  serializeDataIfNeeded,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  toPathString
} from './common'
// @ts-ignore
import { BASE_PATH, BaseAPI, COLLECTION_FORMATS, RequestArgs, RequiredError } from './base'

/**
 *
 * @export
 * @interface APIError
 */
export interface APIError {
  /**
   *
   * @type {APIExceptionType}
   * @memberof APIError
   */
  'type': APIExceptionType;
  /**
   *
   * @type {string}
   * @memberof APIError
   */
  'message': string;
  /**
   *
   * @type {object | Array<object>}
   * @memberof APIError
   */
  'extra': object | Array<object>;
}

/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const APIExceptionType = {
  ValidationError: 'ValidationError',
  InactiveUser: 'InactiveUser',
  InvalidCredit: 'InvalidCredit',
  NeedTwoFactorCode: 'NeedTwoFactorCode',
  NotFound: 'NotFound',
  CantConnectToServer: 'CantConnectToServer',
  Unknown: 'Unknown'
} as const

export type APIExceptionType = typeof APIExceptionType[keyof typeof APIExceptionType];


/**
 *
 * @export
 * @interface DeleteServerResponse
 */
export interface DeleteServerResponse {
  /**
   *
   * @type {boolean}
   * @memberof DeleteServerResponse
   */
  'success': boolean;
}

/**
 *
 * @export
 * @interface Get2FAData
 */
export interface Get2FAData {
  /**
   *
   * @type {string}
   * @memberof Get2FAData
   */
  'code': string;
  /**
   *
   * @type {string}
   * @memberof Get2FAData
   */
  'url': string;
}

/**
 *
 * @export
 * @interface GetMasterInfoResponse
 */
export interface GetMasterInfoResponse {
  /**
   *
   * @type {string}
   * @memberof GetMasterInfoResponse
   */
  'ip': string;
  /**
   *
   * @type {number}
   * @memberof GetMasterInfoResponse
   */
  'port': number;
}

/**
 *
 * @export
 * @interface GetSelfUserResponse
 */
export interface GetSelfUserResponse {
  /**
   *
   * @type {string}
   * @memberof GetSelfUserResponse
   */
  'username': string;
  /**
   *
   * @type {boolean}
   * @memberof GetSelfUserResponse
   */
  'two_factor_enabled': boolean;
  /**
   *
   * @type {string}
   * @memberof GetSelfUserResponse
   */
  'full_name'?: string;
  /**
   *
   * @type {string}
   * @memberof GetSelfUserResponse
   */
  'email'?: string;
}

/**
 *
 * @export
 * @interface GetServerInfoResponse
 */
export interface GetServerInfoResponse {
  /**
   *
   * @type {string}
   * @memberof GetServerInfoResponse
   */
  'os_name': string;
  /**
   *
   * @type {string}
   * @memberof GetServerInfoResponse
   */
  'os_release': string;
  /**
   *
   * @type {string}
   * @memberof GetServerInfoResponse
   */
  'uptime': string;
}

/**
 *
 * @export
 * @interface GetServerResponse
 */
export interface GetServerResponse {
  /**
   *
   * @type {number}
   * @memberof GetServerResponse
   */
  'id': number;
  /**
   *
   * @type {string}
   * @memberof GetServerResponse
   */
  'name': string;
  /**
   *
   * @type {string}
   * @memberof GetServerResponse
   */
  'connect_time': string;
  /**
   *
   * @type {string}
   * @memberof GetServerResponse
   */
  'api_key': string;
  /**
   *
   * @type {boolean}
   * @memberof GetServerResponse
   */
  'online': boolean;
  /**
   *
   * @type {string}
   * @memberof GetServerResponse
   */
  'ip_address': string;
  /**
   *
   * @type {number}
   * @memberof GetServerResponse
   */
  'grpc_port': number;
}

/**
 *
 * @export
 * @interface RecollectedCPUInfo
 */
export interface RecollectedCPUInfo {
  /**
   *
   * @type {string}
   * @memberof RecollectedCPUInfo
   */
  'name': string;
  /**
   *
   * @type {number}
   * @memberof RecollectedCPUInfo
   */
  'load': number;
}

/**
 * rx и tx в bytes/sec.
 * @export
 * @interface RecollectedNetworkInfo
 */
export interface RecollectedNetworkInfo {
  /**
   *
   * @type {string}
   * @memberof RecollectedNetworkInfo
   */
  'name': string;
  /**
   *
   * @type {number}
   * @memberof RecollectedNetworkInfo
   */
  'rx': number;
  /**
   *
   * @type {number}
   * @memberof RecollectedNetworkInfo
   */
  'tx': number;
}

/**
 *
 * @export
 * @interface RecollectedRAMInfo
 */
export interface RecollectedRAMInfo {
  /**
   *
   * @type {number}
   * @memberof RecollectedRAMInfo
   */
  'mem': number;
  /**
   *
   * @type {number}
   * @memberof RecollectedRAMInfo
   */
  'swap': number;
}

/**
 *
 * @export
 * @interface ServersGetCpuStatisticsResponse
 */
export interface ServersGetCpuStatisticsResponse {
  /**
   *
   * @type {string}
   * @memberof ServersGetCpuStatisticsResponse
   */
  'date': string;
  /**
   *
   * @type {Array<RecollectedCPUInfo>}
   * @memberof ServersGetCpuStatisticsResponse
   */
  'info': Array<RecollectedCPUInfo>;
}

/**
 *
 * @export
 * @interface ServersGetNetworkStatisticsResponse
 */
export interface ServersGetNetworkStatisticsResponse {
  /**
   *
   * @type {string}
   * @memberof ServersGetNetworkStatisticsResponse
   */
  'date': string;
  /**
   *
   * @type {Array<RecollectedNetworkInfo>}
   * @memberof ServersGetNetworkStatisticsResponse
   */
  'info': Array<RecollectedNetworkInfo>;
}

/**
 *
 * @export
 * @interface ServersGetRAMStatisticsResponse
 */
export interface ServersGetRAMStatisticsResponse {
  /**
   *
   * @type {string}
   * @memberof ServersGetRAMStatisticsResponse
   */
  'date': string;
  /**
   *
   * @type {RecollectedRAMInfo}
   * @memberof ServersGetRAMStatisticsResponse
   */
  'info': RecollectedRAMInfo;
}

/**
 *
 * @export
 * @interface Set2FAData
 */
export interface Set2FAData {
  /**
   *
   * @type {number}
   * @memberof Set2FAData
   */
  'code': number;
  /**
   *
   * @type {string}
   * @memberof Set2FAData
   */
  'totp_code': string;
}

/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const StatisticType = {
  _5: '5',
  _15: '15',
  _30: '30',
  H: 'h',
  D: 'd',
  W: 'w',
  M: 'm'
} as const

export type StatisticType = typeof StatisticType[keyof typeof StatisticType];


/**
 *
 * @export
 * @interface Token
 */
export interface Token {
  /**
   *
   * @type {string}
   * @memberof Token
   */
  'access_token': string;
  /**
   *
   * @type {string}
   * @memberof Token
   */
  'token_type': string;
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Получение токена по логину и паролю
     * @summary Получение токена
     * @param {string} username
     * @param {string} password
     * @param {number} [twoFactorCode]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccessToken: async (username: string, password: string, twoFactorCode?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'username' is not null or undefined
      assertParamExists('getAccessToken', 'username', username)
      // verify required parameter 'password' is not null or undefined
      assertParamExists('getAccessToken', 'password', password)
      const localVarPath = `/authToken`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      const localVarFormParams = new URLSearchParams()


      if (username !== undefined) {
        localVarFormParams.set('username', username as any)
      }

      if (password !== undefined) {
        localVarFormParams.set('password', password as any)
      }

      if (twoFactorCode !== undefined) {
        localVarFormParams.set('two_factor_code', twoFactorCode as any)
      }


      localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = localVarFormParams.toString()

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
  return {
    /**
     * Получение токена по логину и паролю
     * @summary Получение токена
     * @param {string} username
     * @param {string} password
     * @param {number} [twoFactorCode]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAccessToken(username: string, password: string, twoFactorCode?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Token>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAccessToken(username, password, twoFactorCode, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    }
  }
}

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = AuthApiFp(configuration)
  return {
    /**
     * Получение токена по логину и паролю
     * @summary Получение токена
     * @param {string} username
     * @param {string} password
     * @param {number} [twoFactorCode]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccessToken(username: string, password: string, twoFactorCode?: number, options?: any): AxiosPromise<Token> {
      return localVarFp.getAccessToken(username, password, twoFactorCode, options).then((request) => request(axios, basePath))
    }
  }
}

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
  /**
   * Получение токена по логину и паролю
   * @summary Получение токена
   * @param {string} username
   * @param {string} password
   * @param {number} [twoFactorCode]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public getAccessToken(username: string, password: string, twoFactorCode?: number, options?: AxiosRequestConfig) {
    return AuthApiFp(this.configuration).getAccessToken(username, password, twoFactorCode, options).then((request) => request(this.axios, this.basePath))
  }
}


/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get All Urls
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllUrlsUrlListGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/url-list`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any


      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Get All Urls
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllUrlsUrlListGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAllUrlsUrlListGet(options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    }
  }
}

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = DefaultApiFp(configuration)
  return {
    /**
     *
     * @summary Get All Urls
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllUrlsUrlListGet(options?: any): AxiosPromise<any> {
      return localVarFp.getAllUrlsUrlListGet(options).then((request) => request(axios, basePath))
    }
  }
}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
  /**
   *
   * @summary Get All Urls
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getAllUrlsUrlListGet(options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration).getAllUrlsUrlListGet(options).then((request) => request(this.axios, this.basePath))
  }
}


/**
 * MasterApi - axios parameter creator
 * @export
 */
export const MasterApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Получение информации о мастер сервере
     * @summary Получение мастера
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInfo: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/master`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'OAuth2PasswordBearer', [], configuration)


      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * MasterApi - functional programming interface
 * @export
 */
export const MasterApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = MasterApiAxiosParamCreator(configuration)
  return {
    /**
     * Получение информации о мастер сервере
     * @summary Получение мастера
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getInfo(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMasterInfoResponse<GetServerResponse>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getInfo(options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    }
  }
}

/**
 * MasterApi - factory interface
 * @export
 */
export const MasterApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = MasterApiFp(configuration)
  return {
    /**
     * Получение информации о мастер сервере
     * @summary Получение мастера
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInfo(options?: any): AxiosPromise<GetMasterInfoResponse<GetServerResponse>> {
      return localVarFp.getInfo(options).then((request) => request(axios, basePath))
    }
  }
}

/**
 * MasterApi - object-oriented interface
 * @export
 * @class MasterApi
 * @extends {BaseAPI}
 */
export class MasterApi extends BaseAPI {
  /**
   * Получение информации о мастер сервере
   * @summary Получение мастера
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MasterApi
   */
  public getInfo(options?: AxiosRequestConfig) {
    return MasterApiFp(this.configuration).getInfo(options).then((request) => request(this.axios, this.basePath))
  }
}


/**
 * ServersApi - axios parameter creator
 * @export
 */
export const ServersApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Получение сервера
     * @summary Получение сервера
     * @param {number} serverId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteServer: async (serverId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'serverId' is not null or undefined
      assertParamExists('deleteServer', 'serverId', serverId)
      const localVarPath = `/server/{server_id}`
        .replace(`{${'server_id'}}`, encodeURIComponent(String(serverId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'OAuth2PasswordBearer', [], configuration)


      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Получение статистики CPU сервера
     * @summary Получение статистики CPU
     * @param {number} serverId
     * @param {StatisticType} type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCPUStatistics: async (serverId: number, type: StatisticType, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'serverId' is not null or undefined
      assertParamExists('getCPUStatistics', 'serverId', serverId)
      // verify required parameter 'type' is not null or undefined
      assertParamExists('getCPUStatistics', 'type', type)
      const localVarPath = `/statistics/cpu/{server_id}`
        .replace(`{${'server_id'}}`, encodeURIComponent(String(serverId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'OAuth2PasswordBearer', [], configuration)

      if (type !== undefined) {
        localVarQueryParameter['type'] = type
      }


      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Получение статистики net сервера
     * @summary Получение статистики net
     * @param {number} serverId
     * @param {StatisticType} type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNetworkStatistics: async (serverId: number, type: StatisticType, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'serverId' is not null or undefined
      assertParamExists('getNetworkStatistics', 'serverId', serverId)
      // verify required parameter 'type' is not null or undefined
      assertParamExists('getNetworkStatistics', 'type', type)
      const localVarPath = `/statistics/network/{server_id}`
        .replace(`{${'server_id'}}`, encodeURIComponent(String(serverId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'OAuth2PasswordBearer', [], configuration)

      if (type !== undefined) {
        localVarQueryParameter['type'] = type
      }


      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Получение статистики RAM сервера
     * @summary Получение статистики RAM
     * @param {number} serverId
     * @param {StatisticType} type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRAMStatistics: async (serverId: number, type: StatisticType, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'serverId' is not null or undefined
      assertParamExists('getRAMStatistics', 'serverId', serverId)
      // verify required parameter 'type' is not null or undefined
      assertParamExists('getRAMStatistics', 'type', type)
      const localVarPath = `/statistics/ram/{server_id}`
        .replace(`{${'server_id'}}`, encodeURIComponent(String(serverId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'OAuth2PasswordBearer', [], configuration)

      if (type !== undefined) {
        localVarQueryParameter['type'] = type
      }


      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Получение сервера
     * @summary Получение сервера
     * @param {number} serverId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getServer: async (serverId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'serverId' is not null or undefined
      assertParamExists('getServer', 'serverId', serverId)
      const localVarPath = `/server/{server_id}`
        .replace(`{${'server_id'}}`, encodeURIComponent(String(serverId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'OAuth2PasswordBearer', [], configuration)


      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Получение информации о сервере
     * @summary Получение информации о сервере
     * @param {number} serverId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getServerInfo: async (serverId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'serverId' is not null or undefined
      assertParamExists('getServerInfo', 'serverId', serverId)
      const localVarPath = `/serverInfo/{server_id}`
        .replace(`{${'server_id'}}`, encodeURIComponent(String(serverId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'OAuth2PasswordBearer', [], configuration)


      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Получение списка серверов
     * @summary Получение списка серверов
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getServers: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/servers`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'OAuth2PasswordBearer', [], configuration)


      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * ServersApi - functional programming interface
 * @export
 */
export const ServersApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ServersApiAxiosParamCreator(configuration)
  return {
    /**
     * Получение сервера
     * @summary Получение сервера
     * @param {number} serverId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteServer(serverId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteServerResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteServer(serverId, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Получение статистики CPU сервера
     * @summary Получение статистики CPU
     * @param {number} serverId
     * @param {StatisticType} type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCPUStatistics(serverId: number, type: StatisticType, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ServersGetCpuStatisticsResponse>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getCPUStatistics(serverId, type, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Получение статистики net сервера
     * @summary Получение статистики net
     * @param {number} serverId
     * @param {StatisticType} type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getNetworkStatistics(serverId: number, type: StatisticType, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ServersGetNetworkStatisticsResponse>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getNetworkStatistics(serverId, type, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Получение статистики RAM сервера
     * @summary Получение статистики RAM
     * @param {number} serverId
     * @param {StatisticType} type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRAMStatistics(serverId: number, type: StatisticType, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ServersGetRAMStatisticsResponse>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRAMStatistics(serverId, type, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Получение сервера
     * @summary Получение сервера
     * @param {number} serverId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getServer(serverId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetServerResponse<GetServerResponse>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getServer(serverId, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Получение информации о сервере
     * @summary Получение информации о сервере
     * @param {number} serverId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getServerInfo(serverId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetServerInfoResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getServerInfo(serverId, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Получение списка серверов
     * @summary Получение списка серверов
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getServers(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetServerResponse>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getServers(options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    }
  }
}

/**
 * ServersApi - factory interface
 * @export
 */
export const ServersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = ServersApiFp(configuration)
  return {
    /**
     * Получение сервера
     * @summary Получение сервера
     * @param {number} serverId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteServer(serverId: number, options?: any): AxiosPromise<DeleteServerResponse> {
      return localVarFp.deleteServer(serverId, options).then((request) => request(axios, basePath))
    },
    /**
     * Получение статистики CPU сервера
     * @summary Получение статистики CPU
     * @param {number} serverId
     * @param {StatisticType} type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCPUStatistics(serverId: number, type: StatisticType, options?: any): AxiosPromise<Array<ServersGetCpuStatisticsResponse>> {
      return localVarFp.getCPUStatistics(serverId, type, options).then((request) => request(axios, basePath))
    },
    /**
     * Получение статистики net сервера
     * @summary Получение статистики net
     * @param {number} serverId
     * @param {StatisticType} type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNetworkStatistics(serverId: number, type: StatisticType, options?: any): AxiosPromise<Array<ServersGetNetworkStatisticsResponse>> {
      return localVarFp.getNetworkStatistics(serverId, type, options).then((request) => request(axios, basePath))
    },
    /**
     * Получение статистики RAM сервера
     * @summary Получение статистики RAM
     * @param {number} serverId
     * @param {StatisticType} type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRAMStatistics(serverId: number, type: StatisticType, options?: any): AxiosPromise<Array<ServersGetRAMStatisticsResponse>> {
      return localVarFp.getRAMStatistics(serverId, type, options).then((request) => request(axios, basePath))
    },
    /**
     * Получение сервера
     * @summary Получение сервера
     * @param {number} serverId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getServer(serverId: number, options?: any): AxiosPromise<GetServerResponse<GetServerResponse>> {
      return localVarFp.getServer(serverId, options).then((request) => request(axios, basePath))
    },
    /**
     * Получение информации о сервере
     * @summary Получение информации о сервере
     * @param {number} serverId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getServerInfo(serverId: number, options?: any): AxiosPromise<GetServerInfoResponse> {
      return localVarFp.getServerInfo(serverId, options).then((request) => request(axios, basePath))
    },
    /**
     * Получение списка серверов
     * @summary Получение списка серверов
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getServers(options?: any): AxiosPromise<Array<GetServerResponse>> {
      return localVarFp.getServers(options).then((request) => request(axios, basePath))
    }
  }
}

/**
 * ServersApi - object-oriented interface
 * @export
 * @class ServersApi
 * @extends {BaseAPI}
 */
export class ServersApi extends BaseAPI {
  /**
   * Получение сервера
   * @summary Получение сервера
   * @param {number} serverId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ServersApi
   */
  public deleteServer(serverId: number, options?: AxiosRequestConfig) {
    return ServersApiFp(this.configuration).deleteServer(serverId, options).then((request) => request(this.axios, this.basePath))
  }

  /**
   * Получение статистики CPU сервера
   * @summary Получение статистики CPU
   * @param {number} serverId
   * @param {StatisticType} type
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ServersApi
   */
  public getCPUStatistics(serverId: number, type: StatisticType, options?: AxiosRequestConfig) {
    return ServersApiFp(this.configuration).getCPUStatistics(serverId, type, options).then((request) => request(this.axios, this.basePath))
  }

  /**
   * Получение статистики net сервера
   * @summary Получение статистики net
   * @param {number} serverId
   * @param {StatisticType} type
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ServersApi
   */
  public getNetworkStatistics(serverId: number, type: StatisticType, options?: AxiosRequestConfig) {
    return ServersApiFp(this.configuration).getNetworkStatistics(serverId, type, options).then((request) => request(this.axios, this.basePath))
  }

  /**
   * Получение статистики RAM сервера
   * @summary Получение статистики RAM
   * @param {number} serverId
   * @param {StatisticType} type
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ServersApi
   */
  public getRAMStatistics(serverId: number, type: StatisticType, options?: AxiosRequestConfig) {
    return ServersApiFp(this.configuration).getRAMStatistics(serverId, type, options).then((request) => request(this.axios, this.basePath))
  }

  /**
   * Получение сервера
   * @summary Получение сервера
   * @param {number} serverId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ServersApi
   */
  public getServer(serverId: number, options?: AxiosRequestConfig) {
    return ServersApiFp(this.configuration).getServer(serverId, options).then((request) => request(this.axios, this.basePath))
  }

  /**
   * Получение информации о сервере
   * @summary Получение информации о сервере
   * @param {number} serverId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ServersApi
   */
  public getServerInfo(serverId: number, options?: AxiosRequestConfig) {
    return ServersApiFp(this.configuration).getServerInfo(serverId, options).then((request) => request(this.axios, this.basePath))
  }

  /**
   * Получение списка серверов
   * @summary Получение списка серверов
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ServersApi
   */
  public getServers(options?: AxiosRequestConfig) {
    return ServersApiFp(this.configuration).getServers(options).then((request) => request(this.axios, this.basePath))
  }
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Удалить 2FA
     * @summary Удалить 2FA
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    delete2FA: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/selfUser/2fa`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'OAuth2PasswordBearer', [], configuration)


      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Получить данные для 2FA
     * @summary Получить данные для 2FA
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    get2FAData: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/selfUser/get2FA`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'OAuth2PasswordBearer', [], configuration)


      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Получение текущего пользователя
     * @summary Текущий пользователь
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSelf: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/selfUser`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'OAuth2PasswordBearer', [], configuration)


      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Установить 2FA
     * @summary Установить 2FA
     * @param {Set2FAData} set2FAData
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    set2FA: async (set2FAData: Set2FAData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'set2FAData' is not null or undefined
      assertParamExists('set2FA', 'set2FAData', set2FAData)
      const localVarPath = `/selfUser/2fa`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'OAuth2PasswordBearer', [], configuration)


      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(set2FAData, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
  return {
    /**
     * Удалить 2FA
     * @summary Удалить 2FA
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async delete2FA(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSelfUserResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.delete2FA(options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Получить данные для 2FA
     * @summary Получить данные для 2FA
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async get2FAData(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2FAData>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.get2FAData(options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Получение текущего пользователя
     * @summary Текущий пользователь
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSelf(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSelfUserResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getSelf(options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Установить 2FA
     * @summary Установить 2FA
     * @param {Set2FAData} set2FAData
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async set2FA(set2FAData: Set2FAData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSelfUserResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.set2FA(set2FAData, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    }
  }
}

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = UserApiFp(configuration)
  return {
    /**
     * Удалить 2FA
     * @summary Удалить 2FA
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    delete2FA(options?: any): AxiosPromise<GetSelfUserResponse> {
      return localVarFp.delete2FA(options).then((request) => request(axios, basePath))
    },
    /**
     * Получить данные для 2FA
     * @summary Получить данные для 2FA
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    get2FAData(options?: any): AxiosPromise<Get2FAData> {
      return localVarFp.get2FAData(options).then((request) => request(axios, basePath))
    },
    /**
     * Получение текущего пользователя
     * @summary Текущий пользователь
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSelf(options?: any): AxiosPromise<GetSelfUserResponse> {
      return localVarFp.getSelf(options).then((request) => request(axios, basePath))
    },
    /**
     * Установить 2FA
     * @summary Установить 2FA
     * @param {Set2FAData} set2FAData
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    set2FA(set2FAData: Set2FAData, options?: any): AxiosPromise<GetSelfUserResponse> {
      return localVarFp.set2FA(set2FAData, options).then((request) => request(axios, basePath))
    }
  }
}

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
  /**
   * Удалить 2FA
   * @summary Удалить 2FA
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public delete2FA(options?: AxiosRequestConfig) {
    return UserApiFp(this.configuration).delete2FA(options).then((request) => request(this.axios, this.basePath))
  }

  /**
   * Получить данные для 2FA
   * @summary Получить данные для 2FA
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public get2FAData(options?: AxiosRequestConfig) {
    return UserApiFp(this.configuration).get2FAData(options).then((request) => request(this.axios, this.basePath))
  }

  /**
   * Получение текущего пользователя
   * @summary Текущий пользователь
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public getSelf(options?: AxiosRequestConfig) {
    return UserApiFp(this.configuration).getSelf(options).then((request) => request(this.axios, this.basePath))
  }

  /**
   * Установить 2FA
   * @summary Установить 2FA
   * @param {Set2FAData} set2FAData
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public set2FA(set2FAData: Set2FAData, options?: AxiosRequestConfig) {
    return UserApiFp(this.configuration).set2FA(set2FAData, options).then((request) => request(this.axios, this.basePath))
  }
}


